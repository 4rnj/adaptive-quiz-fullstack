/**
 * Automated Vulnerability Patching System
 * Comprehensive automated patching workflow with safety mechanisms
 */

import { securityLogger, SecurityEventType, SecuritySeverity } from './securityLogging';
import { auditTrail, AuditCategory } from './auditTrail';
import { dependencyAudit, VulnerabilitySeverity, Vulnerability, PackageInfo } from './dependencyAudit';
import { securityAlerts, AlertType } from '../components/security/SecurityAlerts';

// Patch operation types
export enum PatchOperation {
  UPGRADE = 'UPGRADE',
  DOWNGRADE = 'DOWNGRADE',
  REPLACE = 'REPLACE',
  REMOVE = 'REMOVE',
  CONFIGURE = 'CONFIGURE',
}

// Patch status tracking
export enum PatchStatus {
  PENDING = 'PENDING',
  ANALYZING = 'ANALYZING',
  APPROVED = 'APPROVED',
  APPLYING = 'APPLYING',
  TESTING = 'TESTING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  ROLLED_BACK = 'ROLLED_BACK',
  REJECTED = 'REJECTED',
}

// Patch risk levels
export enum PatchRisk {
  LOW = 'LOW',          // Minor version updates, security patches
  MEDIUM = 'MEDIUM',    // Minor breaking changes, API updates
  HIGH = 'HIGH',        // Major version updates, significant changes
  CRITICAL = 'CRITICAL' // Breaking changes, requires manual review
}

// Patch strategy types
export enum PatchStrategy {
  AUTOMATIC = 'AUTOMATIC',     // Auto-apply safe patches
  SEMI_AUTOMATIC = 'SEMI_AUTOMATIC', // Apply with approval
  MANUAL = 'MANUAL',          // Require manual intervention
  SCHEDULED = 'SCHEDULED',    // Apply during maintenance windows
}

// Patch configuration
export interface PatchConfig {
  strategy: PatchStrategy;
  autoApprovalRules: {
    maxRiskLevel: PatchRisk;
    severityThreshold: VulnerabilitySeverity;
    requiresApproval: boolean;
    approverRoles: string[];
  };
  testing: {
    enabled: boolean;
    testCommands: string[];
    timeoutMs: number;
    requiredPassRate: number; // 0-1
  };
  rollback: {
    enabled: boolean;
    triggerConditions: string[];
    maxAttempts: number;
    timeoutMs: number;
  };
  notifications: {
    channels: string[];
    escalationRules: {
      timeToEscalate: number;
      escalateTo: string[];
    };
  };
  maintenanceWindows: {
    enabled: boolean;
    schedules: Array<{
      day: number; // 0-6 (Sunday-Saturday)
      startTime: string; // HH:MM
      endTime: string; // HH:MM
      timezone: string;
    }>;
  };
}

// Patch recommendation
export interface PatchRecommendation {
  id: string;
  packageName: string;
  currentVersion: string;
  targetVersion: string;
  operation: PatchOperation;
  vulnerabilities: Vulnerability[];
  riskLevel: PatchRisk;
  riskScore: number;
  impact: {
    security: number; // 0-10
    stability: number; // 0-10
    performance: number; // 0-10
    compatibility: number; // 0-10
  };
  benefits: string[];
  risks: string[];
  prerequisites: string[];
  testingRequirements: string[];
  estimatedDowntime: number; // minutes
  rollbackPlan: string[];
  createdAt: number;
  validUntil: number;
}

// Patch execution plan
export interface PatchExecutionPlan {
  id: string;
  recommendations: PatchRecommendation[];
  executionOrder: string[]; // recommendation IDs in order
  totalEstimatedTime: number; // minutes
  requiredApprovals: string[];
  preExecutionChecks: string[];
  postExecutionValidation: string[];
  rollbackStrategy: string;
  createdAt: number;
  scheduledFor?: number;
}

// Patch execution result
export interface PatchExecutionResult {
  planId: string;
  recommendationId: string;
  status: PatchStatus;
  startTime: number;
  endTime?: number;
  output: string[];
  errors: string[];
  testResults?: {
    passed: number;
    failed: number;
    skipped: number;
    details: Array<{
      test: string;
      status: 'passed' | 'failed' | 'skipped';
      duration: number;
      error?: string;
    }>;
  };
  rollbackTriggers: string[];
  metrics: {
    downloadTime: number;
    installTime: number;
    testTime: number;
    totalTime: number;
  };
}

// Approval request
export interface ApprovalRequest {
  id: string;
  planId: string;
  recommendationIds: string[];
  requester: string;
  requestedAt: number;
  approvers: Array<{
    email: string;
    role: string;
    required: boolean;
  }>;
  approvals: Array<{
    approver: string;
    approvedAt: number;
    comments?: string;
  }>;
  rejections: Array<{
    rejector: string;
    rejectedAt: number;
    reason: string;
  }>;
  status: 'pending' | 'approved' | 'rejected' | 'expired';
  expiresAt: number;
}

/**
 * Vulnerability Patching Service
 * Automated vulnerability remediation with comprehensive safety mechanisms
 */
export class VulnerabilityPatchingService {
  private static instance: VulnerabilityPatchingService;
  private config: PatchConfig;
  private recommendations = new Map<string, PatchRecommendation>();
  private executionPlans = new Map<string, PatchExecutionPlan>();
  private results = new Map<string, PatchExecutionResult>();
  private approvalRequests = new Map<string, ApprovalRequest>();
  private isPatching = false;
  private patchingQueue: string[] = [];

  private constructor() {
    this.config = this.getDefaultConfig();
    this.startPatchingMonitor();
  }

  public static getInstance(): VulnerabilityPatchingService {
    if (!VulnerabilityPatchingService.instance) {
      VulnerabilityPatchingService.instance = new VulnerabilityPatchingService();
    }
    return VulnerabilityPatchingService.instance;
  }

  /**
   * Analyze vulnerabilities and generate patch recommendations
   */
  public async generatePatchRecommendations(): Promise<PatchRecommendation[]> {
    try {
      console.log('üîç Analyzing vulnerabilities for patch recommendations...');
      
      // Get audit results
      const auditResults = await dependencyAudit.getAuditResults();
      const vulnerablePackages = auditResults.filter(result => result.vulnerabilities.length > 0);
      
      console.log(`üì¶ Found ${vulnerablePackages.length} packages with vulnerabilities`);
      
      const recommendations: PatchRecommendation[] = [];
      
      for (const packageResult of vulnerablePackages) {
        const recommendation = await this.analyzePackageForPatching(packageResult);
        if (recommendation) {
          recommendations.push(recommendation);
          this.recommendations.set(recommendation.id, recommendation);
        }
      }
      
      // Sort by priority (critical vulnerabilities first)
      recommendations.sort((a, b) => {
        const aSeverity = Math.max(...a.vulnerabilities.map(v => this.getSeverityScore(v.severity)));
        const bSeverity = Math.max(...b.vulnerabilities.map(v => this.getSeverityScore(v.severity)));
        
        if (aSeverity !== bSeverity) {
          return bSeverity - aSeverity; // Higher severity first
        }
        
        return a.riskScore - b.riskScore; // Lower risk first for same severity
      });
      
      await securityLogger.logEvent(
        SecurityEventType.SECURITY_EVENT,
        {
          type: 'patch_recommendations_generated',
          count: recommendations.length,
          criticalPatches: recommendations.filter(r => 
            r.vulnerabilities.some(v => v.severity === VulnerabilitySeverity.CRITICAL)
          ).length,
        },
        {
          severity: SecuritySeverity.INFO,
        }
      );
      
      console.log(`‚úÖ Generated ${recommendations.length} patch recommendations`);
      return recommendations;
      
    } catch (error) {
      console.error('‚ùå Failed to generate patch recommendations:', error);
      
      await securityLogger.logEvent(
        SecurityEventType.SECURITY_EVENT,
        {
          type: 'patch_recommendations_failed',
          error: error instanceof Error ? error.message : 'Unknown error',
        },
        {
          severity: SecuritySeverity.HIGH,
        }
      );
      
      throw error;
    }
  }

  /**
   * Create execution plan for patch recommendations
   */
  public async createExecutionPlan(recommendationIds: string[]): Promise<PatchExecutionPlan> {
    const recommendations = recommendationIds
      .map(id => this.recommendations.get(id))
      .filter((rec): rec is PatchRecommendation => rec !== undefined);
    
    if (recommendations.length === 0) {
      throw new Error('No valid recommendations found');
    }
    
    // Analyze dependencies and determine execution order
    const executionOrder = this.optimizeExecutionOrder(recommendations);
    
    // Calculate total time estimate
    const totalEstimatedTime = recommendations.reduce(
      (total, rec) => total + rec.estimatedDowntime, 0
    );
    
    // Determine required approvals
    const requiredApprovals = this.determineRequiredApprovals(recommendations);
    
    const plan: PatchExecutionPlan = {
      id: this.generateId('plan'),
      recommendations,
      executionOrder,
      totalEstimatedTime,
      requiredApprovals,
      preExecutionChecks: [
        'Verify system health',
        'Check available disk space',
        'Validate network connectivity',
        'Backup current state',
        'Notify stakeholders',
      ],
      postExecutionValidation: [
        'Run security scans',
        'Execute test suites',
        'Verify functionality',
        'Check performance metrics',
        'Update documentation',
      ],
      rollbackStrategy: 'Automated rollback on test failure or manual trigger',
      createdAt: Date.now(),
    };
    
    this.executionPlans.set(plan.id, plan);
    
    await securityLogger.logEvent(
      SecurityEventType.SECURITY_EVENT,
      {
        type: 'patch_execution_plan_created',
        planId: plan.id,
        recommendationCount: recommendations.length,
        estimatedTime: totalEstimatedTime,
      },
      {
        severity: SecuritySeverity.INFO,
      }
    );
    
    return plan;
  }

  /**
   * Execute patch plan
   */
  public async executePatchPlan(planId: string): Promise<PatchExecutionResult[]> {
    if (this.isPatching) {
      throw new Error('Another patching operation is already in progress');
    }
    
    const plan = this.executionPlans.get(planId);
    if (!plan) {
      throw new Error(`Execution plan ${planId} not found`);
    }
    
    // Check approvals if required
    if (plan.requiredApprovals.length > 0) {
      const approved = await this.checkApprovals(planId);
      if (!approved) {
        throw new Error('Required approvals not obtained');
      }
    }
    
    this.isPatching = true;
    const results: PatchExecutionResult[] = [];
    
    try {
      console.log(`üöÄ Starting patch execution for plan ${planId}`);
      
      // Pre-execution checks
      await this.runPreExecutionChecks(plan);
      
      // Execute patches in order
      for (const recommendationId of plan.executionOrder) {
        const recommendation = plan.recommendations.find(r => r.id === recommendationId);
        if (!recommendation) continue;
        
        const result = await this.executePatch(plan.id, recommendation);
        results.push(result);
        
        // Check if we should continue or rollback
        if (result.status === PatchStatus.FAILED) {
          if (this.shouldRollback(result)) {
            await this.rollbackPlan(planId, results);
            break;
          }
        }
      }
      
      // Post-execution validation
      await this.runPostExecutionValidation(plan, results);
      
      console.log(`‚úÖ Patch execution completed for plan ${planId}`);
      
      await securityLogger.logEvent(
        SecurityEventType.SECURITY_EVENT,
        {
          type: 'patch_execution_completed',
          planId,
          successCount: results.filter(r => r.status === PatchStatus.COMPLETED).length,
          failureCount: results.filter(r => r.status === PatchStatus.FAILED).length,
        },
        {
          severity: SecuritySeverity.INFO,
        }
      );
      
    } catch (error) {
      console.error(`‚ùå Patch execution failed for plan ${planId}:`, error);
      
      await securityLogger.logEvent(
        SecurityEventType.SECURITY_EVENT,
        {
          type: 'patch_execution_failed',
          planId,
          error: error instanceof Error ? error.message : 'Unknown error',
        },
        {
          severity: SecuritySeverity.HIGH,
        }
      );
      
      // Attempt rollback
      await this.rollbackPlan(planId, results);
      throw error;
      
    } finally {
      this.isPatching = false;
    }
    
    return results;
  }

  /**
   * Request approval for patch plan
   */
  public async requestApproval(
    planId: string,
    requester: string,
    approvers: Array<{ email: string; role: string; required: boolean }>
  ): Promise<ApprovalRequest> {
    const request: ApprovalRequest = {
      id: this.generateId('approval'),
      planId,
      recommendationIds: this.executionPlans.get(planId)?.recommendations.map(r => r.id) || [],
      requester,
      requestedAt: Date.now(),
      approvers,
      approvals: [],
      rejections: [],
      status: 'pending',
      expiresAt: Date.now() + (24 * 60 * 60 * 1000), // 24 hours
    };
    
    this.approvalRequests.set(request.id, request);
    
    // Send notifications to approvers
    await this.notifyApprovers(request);
    
    await securityLogger.logEvent(
      SecurityEventType.SECURITY_EVENT,
      {
        type: 'patch_approval_requested',
        requestId: request.id,
        planId,
        approverCount: approvers.length,
      },
      {
        severity: SecuritySeverity.INFO,
      }
    );
    
    return request;
  }

  /**
   * Approve patch request
   */
  public async approvePatch(requestId: string, approver: string, comments?: string): Promise<void> {
    const request = this.approvalRequests.get(requestId);
    if (!request) {
      throw new Error(`Approval request ${requestId} not found`);
    }
    
    if (request.status !== 'pending') {
      throw new Error(`Approval request ${requestId} is not pending`);
    }
    
    if (Date.now() > request.expiresAt) {
      request.status = 'expired';
      throw new Error(`Approval request ${requestId} has expired`);
    }
    
    // Check if approver is authorized
    const approverInfo = request.approvers.find(a => a.email === approver);
    if (!approverInfo) {
      throw new Error(`${approver} is not authorized to approve this request`);
    }
    
    // Add approval
    request.approvals.push({
      approver,
      approvedAt: Date.now(),
      comments,
    });
    
    // Check if all required approvals are obtained
    const requiredApprovers = request.approvers.filter(a => a.required);
    const requiredApprovals = requiredApprovers.filter(ra => 
      request.approvals.some(a => a.approver === ra.email)
    );
    
    if (requiredApprovals.length === requiredApprovers.length) {
      request.status = 'approved';
      
      // Auto-schedule if configured
      if (this.config.strategy === PatchStrategy.AUTOMATIC) {
        this.scheduleExecution(request.planId);
      }
    }
    
    await securityLogger.logEvent(
      SecurityEventType.SECURITY_EVENT,
      {
        type: 'patch_approval_granted',
        requestId,
        approver,
        status: request.status,
      },
      {
        severity: SecuritySeverity.INFO,
      }
    );
  }

  /**
   * Get patching status and metrics
   */
  public getPatchingStatus(): {
    isPatching: boolean;
    queueLength: number;
    activeRecommendations: number;
    pendingApprovals: number;
    completedPatches: number;
    failedPatches: number;
  } {
    return {
      isPatching: this.isPatching,
      queueLength: this.patchingQueue.length,
      activeRecommendations: this.recommendations.size,
      pendingApprovals: Array.from(this.approvalRequests.values())
        .filter(r => r.status === 'pending').length,
      completedPatches: Array.from(this.results.values())
        .filter(r => r.status === PatchStatus.COMPLETED).length,
      failedPatches: Array.from(this.results.values())
        .filter(r => r.status === PatchStatus.FAILED).length,
    };
  }

  /**
   * Private helper methods
   */

  private async analyzePackageForPatching(packageResult: any): Promise<PatchRecommendation | null> {
    const { package: pkg, vulnerabilities } = packageResult;
    
    // Find the best patch version
    const targetVersion = await this.findBestPatchVersion(pkg, vulnerabilities);
    if (!targetVersion) {
      return null;
    }
    
    // Calculate risk assessment
    const riskAssessment = this.assessPatchRisk(pkg, targetVersion, vulnerabilities);
    
    const recommendation: PatchRecommendation = {
      id: this.generateId('patch'),
      packageName: pkg.name,
      currentVersion: pkg.version,
      targetVersion,
      operation: PatchOperation.UPGRADE,
      vulnerabilities,
      riskLevel: riskAssessment.level,
      riskScore: riskAssessment.score,
      impact: riskAssessment.impact,
      benefits: this.generateBenefits(vulnerabilities),
      risks: riskAssessment.risks,
      prerequisites: this.generatePrerequisites(pkg, targetVersion),
      testingRequirements: this.generateTestingRequirements(pkg),
      estimatedDowntime: this.estimateDowntime(pkg, riskAssessment.level),
      rollbackPlan: this.generateRollbackPlan(pkg),
      createdAt: Date.now(),
      validUntil: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days
    };
    
    return recommendation;
  }

  private async findBestPatchVersion(pkg: PackageInfo, vulnerabilities: Vulnerability[]): Promise<string | null> {
    // In production, this would query npm registry for available versions
    // For demo, use simple logic
    
    const patchVersions: Record<string, string> = {
      'lodash': '4.17.21',
      'axios': '1.6.0',
      'react': '18.2.0',
    };
    
    return patchVersions[pkg.name] || null;
  }

  private assessPatchRisk(pkg: PackageInfo, targetVersion: string, vulnerabilities: Vulnerability[]) {
    // Simple risk assessment algorithm
    let riskScore = 0;
    const risks: string[] = [];
    
    // Version change risk
    const versionDiff = this.calculateVersionDifference(pkg.version, targetVersion);
    if (versionDiff.major > 0) {
      riskScore += 5;
      risks.push('Major version change may introduce breaking changes');
    } else if (versionDiff.minor > 0) {
      riskScore += 2;
      risks.push('Minor version change may affect functionality');
    }
    
    // Vulnerability severity impact
    const criticalVulns = vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL);
    if (criticalVulns.length > 0) {
      riskScore -= 3; // Lower risk score for fixing critical issues
    }
    
    // Package popularity (less risk for popular packages)
    const popularPackages = ['react', 'axios', 'lodash'];
    if (popularPackages.includes(pkg.name)) {
      riskScore -= 1;
    }
    
    riskScore = Math.max(0, Math.min(10, riskScore));
    
    let level: PatchRisk;
    if (riskScore <= 2) level = PatchRisk.LOW;
    else if (riskScore <= 5) level = PatchRisk.MEDIUM;
    else if (riskScore <= 8) level = PatchRisk.HIGH;
    else level = PatchRisk.CRITICAL;
    
    return {
      level,
      score: riskScore,
      risks,
      impact: {
        security: Math.max(...vulnerabilities.map(v => this.getSeverityScore(v.severity))),
        stability: Math.max(1, 5 - versionDiff.major * 2),
        performance: Math.random() * 3 + 7, // Simulated
        compatibility: Math.max(1, 8 - versionDiff.major * 3),
      },
    };
  }

  private calculateVersionDifference(current: string, target: string) {
    const currentParts = current.split('.').map(n => parseInt(n, 10));
    const targetParts = target.split('.').map(n => parseInt(n, 10));
    
    return {
      major: Math.abs((targetParts[0] || 0) - (currentParts[0] || 0)),
      minor: Math.abs((targetParts[1] || 0) - (currentParts[1] || 0)),
      patch: Math.abs((targetParts[2] || 0) - (currentParts[2] || 0)),
    };
  }

  private getSeverityScore(severity: VulnerabilitySeverity): number {
    switch (severity) {
      case VulnerabilitySeverity.CRITICAL: return 10;
      case VulnerabilitySeverity.HIGH: return 8;
      case VulnerabilitySeverity.MEDIUM: return 5;
      case VulnerabilitySeverity.LOW: return 2;
      default: return 0;
    }
  }

  private generateBenefits(vulnerabilities: Vulnerability[]): string[] {
    const benefits = [`Fixes ${vulnerabilities.length} security vulnerabilities`];
    
    const criticalCount = vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL).length;
    const highCount = vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.HIGH).length;
    
    if (criticalCount > 0) {
      benefits.push(`Resolves ${criticalCount} critical security issues`);
    }
    if (highCount > 0) {
      benefits.push(`Addresses ${highCount} high-severity vulnerabilities`);
    }
    
    benefits.push('Improves overall security posture');
    benefits.push('Reduces compliance risks');
    
    return benefits;
  }

  private generatePrerequisites(pkg: PackageInfo, targetVersion: string): string[] {
    return [
      'Backup current application state',
      'Verify no active users during deployment',
      'Ensure sufficient disk space',
      `Test ${pkg.name}@${targetVersion} in staging environment`,
      'Review dependency compatibility',
    ];
  }

  private generateTestingRequirements(pkg: PackageInfo): string[] {
    return [
      'Run unit test suite',
      'Execute integration tests',
      'Perform security scan',
      'Test critical user workflows',
      'Validate API functionality',
      'Check performance benchmarks',
    ];
  }

  private estimateDowntime(pkg: PackageInfo, riskLevel: PatchRisk): number {
    // Estimate in minutes
    const baseTime = 5;
    const riskMultiplier = {
      [PatchRisk.LOW]: 1,
      [PatchRisk.MEDIUM]: 2,
      [PatchRisk.HIGH]: 4,
      [PatchRisk.CRITICAL]: 8,
    };
    
    return baseTime * riskMultiplier[riskLevel];
  }

  private generateRollbackPlan(pkg: PackageInfo): string[] {
    return [
      `Revert ${pkg.name} to previous version`,
      'Restore application state from backup',
      'Verify system functionality',
      'Monitor for issues',
      'Document rollback reason',
    ];
  }

  private optimizeExecutionOrder(recommendations: PatchRecommendation[]): string[] {
    // Simple ordering: critical vulnerabilities first, then by risk score
    return recommendations
      .sort((a, b) => {
        const aCritical = a.vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL).length;
        const bCritical = b.vulnerabilities.filter(v => v.severity === VulnerabilitySeverity.CRITICAL).length;
        
        if (aCritical !== bCritical) {
          return bCritical - aCritical;
        }
        
        return a.riskScore - b.riskScore;
      })
      .map(r => r.id);
  }

  private determineRequiredApprovals(recommendations: PatchRecommendation[]): string[] {
    const approvals: string[] = [];
    
    const hasHighRisk = recommendations.some(r => 
      r.riskLevel === PatchRisk.HIGH || r.riskLevel === PatchRisk.CRITICAL
    );
    
    const hasCriticalVulns = recommendations.some(r => 
      r.vulnerabilities.some(v => v.severity === VulnerabilitySeverity.CRITICAL)
    );
    
    if (hasHighRisk) {
      approvals.push('technical_lead');
    }
    
    if (hasCriticalVulns) {
      approvals.push('security_team');
    }
    
    if (recommendations.length > 5) {
      approvals.push('engineering_manager');
    }
    
    return approvals;
  }

  private async runPreExecutionChecks(plan: PatchExecutionPlan): Promise<void> {
    console.log('üîç Running pre-execution checks...');
    
    for (const check of plan.preExecutionChecks) {
      console.log(`  ‚úì ${check}`);
      // In production, implement actual checks
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  private async executePatch(planId: string, recommendation: PatchRecommendation): Promise<PatchExecutionResult> {
    const startTime = Date.now();
    
    const result: PatchExecutionResult = {
      planId,
      recommendationId: recommendation.id,
      status: PatchStatus.APPLYING,
      startTime,
      output: [],
      errors: [],
      rollbackTriggers: [],
      metrics: {
        downloadTime: 0,
        installTime: 0,
        testTime: 0,
        totalTime: 0,
      },
    };
    
    try {
      console.log(`üì¶ Applying patch: ${recommendation.packageName}@${recommendation.targetVersion}`);
      
      // Simulate patch application
      result.output.push(`Downloading ${recommendation.packageName}@${recommendation.targetVersion}...`);
      await new Promise(resolve => setTimeout(resolve, 1000));
      result.metrics.downloadTime = 1000;
      
      result.output.push(`Installing ${recommendation.packageName}@${recommendation.targetVersion}...`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      result.metrics.installTime = 2000;
      
      // Run tests if configured
      if (this.config.testing.enabled) {
        result.status = PatchStatus.TESTING;
        result.output.push('Running test suite...');
        
        const testResults = await this.runTests(recommendation);
        result.testResults = testResults;
        result.metrics.testTime = testResults.details.reduce((sum, t) => sum + t.duration, 0);
        
        const passRate = testResults.passed / (testResults.passed + testResults.failed);
        if (passRate < this.config.testing.requiredPassRate) {
          throw new Error(`Test pass rate ${passRate.toFixed(2)} below required ${this.config.testing.requiredPassRate}`);
        }
      }
      
      result.status = PatchStatus.COMPLETED;
      result.endTime = Date.now();
      result.metrics.totalTime = result.endTime - startTime;
      
      console.log(`‚úÖ Patch applied successfully: ${recommendation.packageName}`);
      
    } catch (error) {
      result.status = PatchStatus.FAILED;
      result.endTime = Date.now();
      result.errors.push(error instanceof Error ? error.message : 'Unknown error');
      result.rollbackTriggers.push('patch_application_failed');
      
      console.error(`‚ùå Patch failed: ${recommendation.packageName}`, error);
    }
    
    this.results.set(result.recommendationId, result);
    return result;
  }

  private async runTests(recommendation: PatchRecommendation): Promise<any> {
    // Simulate test execution
    const tests = [
      'Unit tests',
      'Integration tests',
      'Security tests',
      'Performance tests',
    ];
    
    const results = {
      passed: 0,
      failed: 0,
      skipped: 0,
      details: [] as any[],
    };
    
    for (const test of tests) {
      const duration = Math.random() * 1000 + 500;
      const passed = Math.random() > 0.1; // 90% pass rate
      
      results.details.push({
        test,
        status: passed ? 'passed' : 'failed',
        duration,
        error: passed ? undefined : 'Simulated test failure',
      });
      
      if (passed) {
        results.passed++;
      } else {
        results.failed++;
      }
      
      await new Promise(resolve => setTimeout(resolve, duration));
    }
    
    return results;
  }

  private shouldRollback(result: PatchExecutionResult): boolean {
    return this.config.rollback.enabled && (
      result.status === PatchStatus.FAILED ||
      result.rollbackTriggers.length > 0
    );
  }

  private async rollbackPlan(planId: string, results: PatchExecutionResult[]): Promise<void> {
    console.log(`üîÑ Rolling back patch plan ${planId}...`);
    
    // Rollback completed patches in reverse order
    const completedResults = results
      .filter(r => r.status === PatchStatus.COMPLETED)
      .reverse();
    
    for (const result of completedResults) {
      await this.rollbackPatch(result);
    }
    
    console.log(`‚úÖ Rollback completed for plan ${planId}`);
  }

  private async rollbackPatch(result: PatchExecutionResult): Promise<void> {
    console.log(`üîÑ Rolling back patch: ${result.recommendationId}`);
    
    result.status = PatchStatus.ROLLED_BACK;
    
    // In production, implement actual rollback logic
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    console.log(`‚úÖ Rollback completed: ${result.recommendationId}`);
  }

  private async runPostExecutionValidation(plan: PatchExecutionPlan, results: PatchExecutionResult[]): Promise<void> {
    console.log('üîç Running post-execution validation...');
    
    for (const validation of plan.postExecutionValidation) {
      console.log(`  ‚úì ${validation}`);
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }

  private async checkApprovals(planId: string): Promise<boolean> {
    const requests = Array.from(this.approvalRequests.values())
      .filter(r => r.planId === planId);
    
    return requests.every(r => r.status === 'approved');
  }

  private async notifyApprovers(request: ApprovalRequest): Promise<void> {
    // In production, send notifications via configured channels
    console.log(`üìß Notification sent to ${request.approvers.length} approvers for request ${request.id}`);
  }

  private scheduleExecution(planId: string): void {
    if (this.config.maintenanceWindows.enabled) {
      // Schedule for next maintenance window
      console.log(`üìÖ Scheduled execution for plan ${planId} during next maintenance window`);
    } else {
      // Add to immediate execution queue
      this.patchingQueue.push(planId);
    }
  }

  private startPatchingMonitor(): void {
    // Process patching queue
    setInterval(async () => {
      if (!this.isPatching && this.patchingQueue.length > 0) {
        const planId = this.patchingQueue.shift();
        if (planId) {
          try {
            await this.executePatchPlan(planId);
          } catch (error) {
            console.error('Queued patch execution failed:', error);
          }
        }
      }
    }, 30000); // Check every 30 seconds
  }

  private getDefaultConfig(): PatchConfig {
    return {
      strategy: PatchStrategy.SEMI_AUTOMATIC,
      autoApprovalRules: {
        maxRiskLevel: PatchRisk.LOW,
        severityThreshold: VulnerabilitySeverity.HIGH,
        requiresApproval: true,
        approverRoles: ['security_team', 'technical_lead'],
      },
      testing: {
        enabled: true,
        testCommands: ['npm test', 'npm run test:integration'],
        timeoutMs: 300000, // 5 minutes
        requiredPassRate: 0.95,
      },
      rollback: {
        enabled: true,
        triggerConditions: ['test_failure', 'deployment_failure'],
        maxAttempts: 3,
        timeoutMs: 600000, // 10 minutes
      },
      notifications: {
        channels: ['email', 'slack'],
        escalationRules: {
          timeToEscalate: 3600000, // 1 hour
          escalateTo: ['security_team', 'engineering_manager'],
        },
      },
      maintenanceWindows: {
        enabled: false,
        schedules: [
          {
            day: 0, // Sunday
            startTime: '02:00',
            endTime: '06:00',
            timezone: 'UTC',
          },
        ],
      },
    };
  }

  private generateId(prefix: string): string {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

// Global instance
export const vulnerabilityPatching = VulnerabilityPatchingService.getInstance();